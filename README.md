# LightweightRPC-Framework 🚀

## 前言
我最近一段时间在学习RPC框架，这个过程中我搜寻了一些优秀的开源项目和一些教程，一些项目做的非常丰富，我在一开始学习的时候会觉得比较吃力，所以在结束这段时间的学习之后萌生了自己写一个更详细更面向我自己这样小白的学习路线，这就是这个项目的初衷。
希望能在这个过程中一方面检验自己的学习成果，另一方面也希望能为你带来帮助。

这个项目会有多个版本，希望能展示出不同的技术方案解决了什么样的问题，简化了哪一方面的开发，这也是我在学习的过程中收获到的感触。

## 项目概述
一个采用渐进迭代设计的轻量级RPC框架教学项目，通过版本演进展示RPC核心技术的实现原理。项目从零开始构建，逐步集成网络通信、协议设计、服务发现等关键模块，最终形成完整的分布式服务调用框架。

## 📌 项目特色
- ​**渐进式学习路径**：通过6个版本迭代展示项目的演进过程
- ​**模块化设计**：每个版本聚焦解决特定技术问题，形成清晰的技术演进图谱
- ​**最后实现**：集成Netty、Zookeeper等组件，覆盖服务发现、负载均衡等关键特性

## 🚀 版本演进路线

| 版本            | 核心特性                               | 技术里程碑                          | 状态  |
|----------------|------------------------------------|---------------------------------|-----|
| LocalMethod    | 本地方法调用基础实现                        | 建立RPC与本地调用的对比基准               | ✅   |
| SimpleRpcV1    | 基于BIO Socket通信<br>Java原生序列化        | 实现基础远程调用能力                   | ✅   |
| SimpleRpcV2    | 自定义二进制协议<br>JSON序列化               | 解决粘包问题<br>实现跨语言支持            | ✅   |
| SimpleRpcV3    | Zookeeper服务注册中心                    | 实现服务动态发现能力                   | ◻️  |
| SimpleRpcV4    | 负载均衡算法（随机/轮询）<br>失败重试机制         | 提升系统可用性与扩展性                 | ◻️  |
| SimpleRpcV5    | Netty NIO通信<br>连接池复用               | 提升网络吞吐量<br>支持高并发场景           | ◻️  |

## 🛠 架构演进简介

（每个版本中有更详细的说明）

RPC是基于网络的远程方法调用，实现的目标是想要让用户像调用本地方法一样去调用远程方法。

在我最开始接触到这个概念的时候，我第一时间想到的解决方案是将用户调用的方法名称以及参数打包好传送给服务端，
服务端调用方法，将结果返回给客户端，只要将这一系列操作封装起来就可以了，这就是SimpleRpcV1干的事情。SimpleV1使用Java原生序列化，基于Socket通信实现远程调用。

但是再V1里，使用的序列化方法是Java原生序列化方法，会有两个问题，第一，Java原生序列化方法会产生大量冗余字节，第二，原生序列化只能用于Java系统，无法与Python、Go等其他语言的服务互通。

上述问题再SimpleRpcV2中得到解决，V2中自定义了通信协议，包含消息头和消息体。消息头包含魔数、协议版本、消息类型、以及消息体长度（解决粘包问题）、消息体（序列化好之后的）。
在V2中还使用了JSON序列化方案，减少了原生序列化导致的数据冗余问题，减少了数据包的体积，也实现了多语言兼容。

待更新......

